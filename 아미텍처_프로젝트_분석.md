# 아키텍처 스터디 프로젝트 분석

## 프로젝트 개요
이 프로젝트는 소프트웨어 아키텍처 패턴을 학습하기 위한 스터디 프로젝트로, 동일한 기능을 구현하는 두 가지 다른 아키텍처 패턴(3-tier와 4-tier)을 비교할 수 있도록 구성되어 있습니다. 각 모듈은 간단한 컨퍼런스 참가자 등록 시스템을 구현하고 있습니다.

## 3-tier 아키텍처 분석

### 구조 개요
3-tier 아키텍처는 애플리케이션을 세 개의 논리적 계층으로 나눕니다:

1. **프레젠테이션 계층 (웹 계층)**
   - HTTP 요청과 응답을 처리합니다.
   - 클라이언트에게 뷰를 렌더링하거나 데이터를 반환합니다.
   - 기본적인 입력 유효성 검사를 수행합니다.
   - 주요 파일: `WebController.java`

2. **비즈니스 계층 (서비스 계층)**
   - 비즈니스 로직을 포함합니다.
   - 프레젠테이션 계층과 데이터 계층 사이의 데이터 흐름을 조정합니다.
   - 비즈니스 유효성 검사를 수행합니다.
   - 주요 파일: `ConferenceService.java`

3. **데이터 계층 (리포지토리 계층)**
   - 데이터 영속성과 검색을 처리합니다.
   - 데이터베이스와 상호작용합니다.
   - 주요 파일: `ConferenceRepository.java`, `ConferenceRepositoryImpl.java`, `ConferenceEntity.java`

### 데이터 전송
- 프레젠테이션 계층과 비즈니스 계층 사이에는 DTO(`ConferenceDto.java`)를 사용하여 데이터를 전송합니다.
- 비즈니스 계층은 데이터 계층의 엔티티를 직접 사용합니다.

### 주요 특징
- 명확한 관심사 분리
- 각 계층은 특정 책임을 가집니다.
- 계층은 잘 정의된 인터페이스를 통해 통신합니다.
- 상위 계층은 하위 계층에 의존하지만, 그 반대는 아닙니다.
- 서비스 계층에서 엔티티를 직접 사용합니다.
- 엔티티 모델과 별도의 도메인 모델이 없습니다.

### 주요 클래스 분석
1. **WebController**: 프레젠테이션 계층의 핵심 클래스로, HTTP 요청을 처리하고 ConferenceService를 호출하여 비즈니스 로직을 실행합니다.
2. **ConferenceService**: 비즈니스 계층의 핵심 클래스로, 참가자 등록, 조회 등의 비즈니스 로직을 구현하고 ConferenceRepository를 통해 데이터 접근을 수행합니다.
3. **ConferenceRepository**: 데이터 계층의 인터페이스로, 데이터 접근 메서드를 정의합니다.
4. **ConferenceRepositoryImpl**: ConferenceRepository의 구현체로, MyBatis 매퍼를 사용하여 실제 데이터베이스 접근을 수행합니다.
5. **ConferenceEntity**: 데이터베이스 테이블의 레코드를 표현하는 엔티티 클래스입니다.

## 4-tier 아키텍처 분석

### 구조 개요
4-tier 아키텍처는 애플리케이션을 네 개의 논리적 계층으로 나눕니다:

1. **프레젠테이션 계층 (웹 계층)**
   - HTTP 요청과 응답을 처리합니다.
   - 클라이언트에게 뷰를 렌더링하거나 데이터를 반환합니다.
   - 기본적인 입력 유효성 검사를 수행합니다.
   - 자체 DTO를 사용합니다.
   - 주요 파일: `WebController.java`, `ConferenceResponse.java`, `ConferenceRequest.java`

2. **애플리케이션 계층 (서비스 계층)**
   - 유스케이스의 흐름을 조정합니다.
   - 도메인 객체를 조정합니다.
   - 트랜잭션을 관리합니다.
   - 도메인 객체와 DTO 간의 변환을 수행합니다.
   - 주요 파일: `ConferenceService.java`, `ConferenceDto.java`

3. **도메인 계층**
   - 핵심 비즈니스 로직과 규칙을 포함합니다.
   - 비즈니스 개념과 관계를 표현합니다.
   - 비즈니스 엔티티의 상태와 행동을 캡슐화합니다.
   - 주요 파일: `Conference.java`

4. **인프라스트럭처 계층**
   - 다른 계층을 지원하는 기술적 기능을 제공합니다.
   - 영속성 메커니즘을 구현합니다.
   - 도메인 모델과 외부 시스템 간의 적응을 수행합니다.
   - 주요 파일: `ConferenceRepository.java`, `ConferenceRepositoryImpl.java`, `ConferenceEntity.java`, `ConferenceMapper.java`

### 데이터 전송
- 프레젠테이션 계층과 애플리케이션 계층 사이에는 DTO를 사용하여 데이터를 전송합니다.
- 애플리케이션 계층은 도메인 객체와 작업합니다.
- 인프라스트럭처 계층은 도메인 객체와 엔티티 간의 변환을 수행합니다.

### 주요 특징
- 명확한 관심사 분리
- 각 계층은 특정 책임을 가집니다.
- 도메인 모델은 인프라스트럭처 관심사로부터 격리됩니다.
- 프레젠테이션 계층은 도메인 계층과 직접 상호작용하지 않습니다.
- 도메인 객체는 프레젠테이션 계층에 노출되지 않습니다.
- 엔티티는 애플리케이션 계층에 노출되지 않습니다.

### 주요 클래스 분석
1. **WebController**: 프레젠테이션 계층의 핵심 클래스로, HTTP 요청을 처리하고 ConferenceService를 호출하여 애플리케이션 로직을 실행합니다.
2. **ConferenceService**: 애플리케이션 계층의 핵심 클래스로, 유스케이스 흐름을 조정하고 도메인 객체와 DTO 간의 변환을 수행합니다.
3. **Conference**: 도메인 계층의 핵심 클래스로, 비즈니스 개념과 규칙을 캡슐화합니다. 불변성을 강조하고 팩토리 메서드를 통해 객체 생성을 제어합니다.
4. **ConferenceRepository**: 인프라스트럭처 계층의 인터페이스로, 도메인 객체의 영속성 메서드를 정의합니다.
5. **ConferenceRepositoryImpl**: ConferenceRepository의 구현체로, 도메인 객체와 엔티티 간의 변환을 수행하고 MyBatis 매퍼를 사용하여 실제 데이터베이스 접근을 수행합니다.
6. **ConferenceEntity**: 데이터베이스 테이블의 레코드를 표현하는 엔티티 클래스로, 도메인 객체와의 변환 메서드를 제공합니다.

## 두 아키텍처의 주요 차이점

1. **계층 구조**:
   - 3-tier: 프레젠테이션, 비즈니스, 데이터 계층으로 구성
   - 4-tier: 프레젠테이션, 애플리케이션, 도메인, 인프라스트럭처 계층으로 구성

2. **도메인 모델**:
   - 3-tier: 별도의 도메인 모델이 없으며, 서비스 계층에서 엔티티를 직접 사용
   - 4-tier: 독립적인 도메인 모델(Conference)이 있으며, 비즈니스 로직과 규칙을 캡슐화

3. **데이터 전송**:
   - 3-tier: 프레젠테이션과 비즈니스 계층 사이에만 DTO 사용
   - 4-tier: 각 계층마다 자체 데이터 모델을 가지며, 계층 간 변환 로직이 명확히 정의됨

4. **객체 불변성**:
   - 3-tier: 엔티티에 setter 메서드가 있어 상태 변경이 자유로움
   - 4-tier: 도메인 객체는 setter 없이 불변성을 강조하고, 팩토리 메서드를 통해 객체 생성을 제어

5. **의존성 방향**:
   - 3-tier: 상위 계층이 하위 계층에 의존
   - 4-tier: 도메인 계층이 중심이 되며, 인프라스트럭처 계층이 도메인 계층에 의존(의존성 역전)

## 결론

이 프로젝트는 동일한 기능을 구현하는 두 가지 다른 아키텍처 패턴을 비교함으로써, 각 아키텍처의 장단점과 적용 방식을 학습할 수 있도록 설계되었습니다. 3-tier 아키텍처는 구현이 단순하고 직관적이지만, 도메인 로직과 인프라스트럭처 관심사가 혼합될 수 있습니다. 반면 4-tier 아키텍처는 더 복잡하지만, 도메인 로직을 명확히 분리하고 테스트 용이성과 유지보수성을 향상시킬 수 있습니다.

특히 4-tier 아키텍처는 도메인 주도 설계(DDD)와 클린 아키텍처의 원칙을 반영하고 있으며, 복잡한 비즈니스 로직을 가진 엔터프라이즈 애플리케이션에 더 적합할 수 있습니다. 반면 3-tier 아키텍처는 간단한 CRUD 애플리케이션이나 빠른 개발이 필요한 프로젝트에 더 적합할 수 있습니다.